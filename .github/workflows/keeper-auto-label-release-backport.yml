---
name: "Keeper: auto-label release and backport from YAML frontmatter"

'on':
  pull_request:
    types: [opened, synchronize]

permissions:
  pull-requests: write

jobs:
  auto-label-release-backport:
    runs-on: ubuntu-latest

    # CHANGE THIS: set your repo name here
    # this is used to prevent the workflow from running on other repos/forks
    if: github.repository == 'thenets/repo-automations'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Parse YAML frontmatter and add labels
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Get list of changed files in the PR
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            console.log(`Found ${files.length} changed files in PR #${context.issue.number}`);

            let yamlFound = false;
            let releaseLabel = null;
            let backportLabel = null;

            // Check each changed file for YAML frontmatter
            for (const file of files) {
              if (file.status === 'added' || file.status === 'modified') {
                try {
                  const response = await github.rest.repos.getContent({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    path: file.filename,
                    ref: context.payload.pull_request.head.sha
                  });

                  const content = Buffer.from(response.data.content, 'base64').toString('utf8');
                  const lines = content.split('\n');

                  // Check for YAML frontmatter at the beginning of the file
                  if (lines.length > 0 && lines[0].trim() === '---') {
                    console.log(`Found YAML frontmatter in ${file.filename}`);

                    // Find the end of YAML frontmatter
                    let yamlEndIndex = -1;
                    for (let i = 1; i < lines.length; i++) {
                      if (lines[i].trim() === '---') {
                        yamlEndIndex = i;
                        break;
                      }
                    }

                    if (yamlEndIndex > 0) {
                      // Extract YAML content
                      const yamlContent = lines.slice(1, yamlEndIndex).join('\n');
                      console.log(`YAML frontmatter found:\n${yamlContent}`);

                      // Parse release and backport values
                      const releaseMatch = yamlContent.match(/^release:\s*(.+)$/m);
                      const backportMatch = yamlContent.match(/^backport:\s*(.+)$/m);

                      if (releaseMatch) {
                        const releaseValue = releaseMatch[1].trim().replace(/#.*$/, '').trim();
                        releaseLabel = `release ${releaseValue}`;
                        console.log(`Found release: ${releaseValue}`);
                        yamlFound = true;
                      }

                      if (backportMatch) {
                        const backportValue = backportMatch[1].trim().replace(/#.*$/, '').trim();
                        backportLabel = `backport ${backportValue}`;
                        console.log(`Found backport: ${backportValue}`);
                        yamlFound = true;
                      }

                      // Stop after finding the first file with YAML frontmatter
                      if (yamlFound) break;
                    }
                  }

                  // Also check for YAML blocks inside HTML comments (at the top of the file)
                  if (!yamlFound && lines.length > 0) {
                    const topContent = lines.slice(0, 20).join('\n'); // Check first 20 lines

                    // Look for HTML comment with YAML block
                    const commentMatch = topContent.match(/<!--\s*\n?\s*```yaml\s*\n([\s\S]*?)\n\s*```\s*\n?\s*-->/);
                    if (commentMatch) {
                      const yamlContent = commentMatch[1];
                      console.log(`YAML block in HTML comment found in ${file.filename}:\n${yamlContent}`);

                      // Parse release and backport values
                      const releaseMatch = yamlContent.match(/^release:\s*(.+)$/m);
                      const backportMatch = yamlContent.match(/^backport:\s*(.+)$/m);

                      if (releaseMatch) {
                        const releaseValue = releaseMatch[1].trim().replace(/#.*$/, '').trim();
                        releaseLabel = `release ${releaseValue}`;
                        console.log(`Found release: ${releaseValue}`);
                        yamlFound = true;
                      }

                      if (backportMatch) {
                        const backportValue = backportMatch[1].trim().replace(/#.*$/, '').trim();
                        backportLabel = `backport ${backportValue}`;
                        console.log(`Found backport: ${backportValue}`);
                        yamlFound = true;
                      }

                      // Stop after finding the first file with YAML block
                      if (yamlFound) break;
                    }
                  }
                } catch (error) {
                  console.log(`Could not read file ${file.filename}: ${error.message}`);
                }
              }
            }

            if (!yamlFound) {
              console.log('No YAML frontmatter or YAML blocks found in any changed files');
              return;
            }

            // Add labels to the PR
            const labelsToAdd = [];
            if (releaseLabel) labelsToAdd.push(releaseLabel);
            if (backportLabel) labelsToAdd.push(backportLabel);

            if (labelsToAdd.length > 0) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: labelsToAdd
                });
                console.log(`Successfully added labels: ${labelsToAdd.join(', ')}`);
              } catch (error) {
                if (error.status === 422) {
                  console.log('Some labels may already exist on the PR');
                } else {
                  console.error('Error adding labels:', error);
                }
              }
            }