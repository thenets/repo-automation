---
# GitHub Repository Automations - Keeper: auto-label release and backport
# MIT License - Copyright (c) 2025 Luiz Felipe F M Costa
# Source: https://github.com/thenets/repo-automations
#
# PERMISSIONS REQUIRED FOR FINE-GRAINED PERSONAL ACCESS TOKEN:
# When using a custom token (CUSTOM_GITHUB_TOKEN secret), the token must have:
# - Repository access: This repository (or "All repositories" for organization-wide use)
# - Repository permissions:
#   - Issues: Write (to add labels to issues)
#   - Pull requests: Write (to add labels to pull requests)
#   - Metadata: Read (to access repository information)
#
# SETUP INSTRUCTIONS:
# 1. Create a fine-grained personal access token at: https://github.com/settings/tokens?type=beta
# 2. Grant the permissions listed above
# 3. Add the token as a repository secret named 'CUSTOM_GITHUB_TOKEN'
# 4. This enables the workflow to run successfully for external contributors
#
# NOTE: Without a custom token, the workflow may fail for external contributors
# due to GitHub's default token permission restrictions.

name: "Keeper: auto-label release and backport from PR description"

'on':
  workflow_run:
    workflows: ["Keeper: trigger"]
    types: [completed]

permissions:
  pull-requests: write

jobs:
  auto-label-release-backport:
    runs-on: ubuntu-latest

    if: github.event.workflow_run.conclusion == 'success'

    steps:
      - name: Download event metadata
        uses: actions/download-artifact@v4
        with:
          name: event-metadata
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}

      - name: Parse YAML from PR description and add labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CUSTOM_GITHUB_TOKEN || github.token }}
          script: |
            try {
              console.log(`🔍 Processing PR #${context.issue.number}`);

              // Download and read the event metadata
              const fs = require('fs');
              let eventData;
              let workflowConfig;

              try {
                const eventMetadata = fs.readFileSync('event-metadata.json', 'utf8');
                eventData = JSON.parse(eventMetadata);
                console.log(`📥 Event data loaded: ${eventData.event_type} for #${eventData.issue_number}`);
              } catch (error) {
                console.log('❌ No event metadata found, exiting gracefully');
                return;
              }

              try {
                const configData = fs.readFileSync('workflow-config.json', 'utf8');
                workflowConfig = JSON.parse(configData);
                console.log(`📋 Configuration loaded: ${workflowConfig.accepted_releases.length} releases, ${workflowConfig.accepted_backports.length} backports`);
              } catch (error) {
                console.log('❌ No workflow configuration found, exiting gracefully');
                return;
              }

              // Skip if not a pull request event
              if (eventData.event_type !== 'pull_request') {
                console.log(`⏭️ Skipping ${eventData.event_type} event`);
                return;
              }

              // Skip if pull request is a draft
              if (eventData.draft) {
                console.log('⏭️ Skipping draft pull request');
                return;
              }

              const acceptedReleases = workflowConfig.accepted_releases;
              const acceptedBackports = workflowConfig.accepted_backports;

              // Get current labels
              const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: eventData.issue_number
              });

              const existingLabelNames = currentLabels.map(label => label.name);
              console.log(`Current labels: ${existingLabelNames.join(', ')}`);

              // Check if release/backport labels already exist
              const hasReleaseLabel = existingLabelNames.some(label => label.startsWith('release '));
              const hasBackportLabel = existingLabelNames.some(label => label.startsWith('backport '));

              console.log(`Has existing release label: ${hasReleaseLabel}`);
              console.log(`Has existing backport label: ${hasBackportLabel}`);

              // Get PR description from artifact
              const prBody = eventData.body || '';
              console.log(`PR description:\n${prBody}`);

              let yamlFound = false;
              let releaseLabel = null;
              let backportLabel = null;
              const validationErrors = [];

              // Look for YAML code blocks in the PR description
              const yamlBlockRegex = /```yaml\s*\n([\s\S]*?)\n\s*```/g;
              let match;

              while ((match = yamlBlockRegex.exec(prBody)) !== null) {
                const yamlContent = match[1];
                console.log(`Found YAML block:\n${yamlContent}`);

                // Parse release and backport values
                const releaseMatch = yamlContent.match(/^release:\s*(.+)$/m);
                const backportMatch = yamlContent.match(/^backport:\s*(.+)$/m);

                if (releaseMatch) {
                  const releaseValue = releaseMatch[1].trim().replace(/#.*$/, '').trim()
                    .replace(/^["']|["']$/g, ''); // Remove surrounding single or double quotes
                  if (releaseValue === '') {
                    // Empty value - skip gracefully
                    console.log('Empty release value found, skipping');
                  } else if (hasReleaseLabel) {
                    // Release label already exists - skip to preserve existing label
                    console.log(`Release label already exists, skipping automatic assignment of "release ${releaseValue}"`);
                  } else if (acceptedReleases.includes(releaseValue)) {
                    // Valid value and no existing label - add label
                    releaseLabel = `release ${releaseValue}`;
                    console.log(`Found valid release: ${releaseValue}`);
                    yamlFound = true;
                  } else {
                    // Invalid value - collect error
                    const errorMsg = `❌ Invalid release value: "${releaseValue}". Accepted values: ${acceptedReleases.join(', ')}`;
                    console.error(errorMsg);
                    validationErrors.push(errorMsg);
                  }
                }

                if (backportMatch) {
                  const backportValue = backportMatch[1].trim().replace(/#.*$/, '').trim()
                    .replace(/^["']|["']$/g, ''); // Remove surrounding single or double quotes
                  if (backportValue === '') {
                    // Empty value - skip gracefully
                    console.log('Empty backport value found, skipping');
                  } else if (hasBackportLabel) {
                    // Backport label already exists - skip to preserve existing label
                    console.log(`Backport label already exists, skipping automatic assignment of "backport ${backportValue}"`);
                  } else if (acceptedBackports.includes(backportValue)) {
                    // Valid value and no existing label - add label
                    backportLabel = `backport ${backportValue}`;
                    console.log(`Found valid backport: ${backportValue}`);
                    yamlFound = true;
                  } else {
                    // Invalid value - collect error
                    const errorMsg = `❌ Invalid backport value: "${backportValue}". Accepted values: ${acceptedBackports.join(', ')}`;
                    console.error(errorMsg);
                    validationErrors.push(errorMsg);
                  }
                }

                // Stop after finding the first YAML block with any content (valid or processed)
                if (releaseMatch || backportMatch) break;
              }

              // If there are validation errors, post a comment and fail
              if (validationErrors.length > 0) {
                const errorComment = '## 🚨 YAML Validation Error\n\n' +
                  validationErrors.map(error => `- ${error}`).join('\n') + '\n\n' +
                  '### How to fix:\n' +
                  '1. Update your PR description YAML block with valid values\n' +
                  '2. The workflow will automatically re-run when you edit the description\n\n' +
                  '### Valid YAML format:\n' +
                  '```yaml\n' +
                  `release: 1.5    # Valid releases: ${acceptedReleases.join(', ')}\n` +
                  `backport: 1.4   # Valid backports: ${acceptedBackports.join(', ')}\n` +
                  '```\n\n' +
                  `_This comment was posted by the [keeper-auto-label-release-backport workflow](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/workflows/keeper-auto-label-release-backport.yml)._`;

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: eventData.issue_number,
                  body: errorComment
                });

                console.log('💬 Posted validation error comment to PR');
                throw new Error(validationErrors.join('; '));
              }

              if (!yamlFound) {
                console.log('No valid YAML code blocks found in PR description');
                return;
              }

              // Add labels to the PR
              const labelsToAdd = [];
              if (releaseLabel) labelsToAdd.push(releaseLabel);
              if (backportLabel) labelsToAdd.push(backportLabel);

              if (labelsToAdd.length > 0) {
                try {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: eventData.issue_number,
                    labels: labelsToAdd
                  });
                  console.log(`✅ Successfully added labels: ${labelsToAdd.join(', ')}`);
                } catch (error) {
                  if (error.status === 403) {
                    const errorMsg = `❌ Permission denied: Unable to add labels "${labelsToAdd.join(', ')}" to PR #${eventData.issue_number}. This typically happens when the workflow is triggered by an external contributor and the repository doesn't have a CUSTOM_GITHUB_TOKEN secret configured with appropriate permissions. Repository administrators should add a CUSTOM_GITHUB_TOKEN secret with 'Issues: Write' and 'Pull requests: Write' permissions.`;
                    console.error(errorMsg);
                    console.error('Error details:', error);
                    throw new Error(errorMsg);
                  } else if (error.status === 422) {
                    // Label doesn't exist - provide helpful message
                    const errorMsg = `❌ Label creation failed: One or more labels "${labelsToAdd.join(', ')}" don't exist in the repository. Repository administrators should create these labels first, or the workflow will create them automatically if it has sufficient permissions.`;
                    console.error(errorMsg);
                    console.error('Error details:', error);
                    throw new Error(errorMsg);
                  } else {
                    console.error('Unexpected error adding labels:', error);
                    throw error;
                  }
                }
              }

              console.log('🎉 Release and backport labeling completed successfully');

            } catch (error) {
              // Log the error for debugging
              console.error('🚨 Workflow failed:', error.message);

              // Re-throw to ensure workflow fails
              throw error;
            }
