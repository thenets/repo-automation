---
# GitHub Repository Automations - Keeper: feature branch auto-labeling
# MIT License - Copyright (c) 2025 Luiz Felipe F M Costa
# Source: https://github.com/thenets/repo-automations
#
# PERMISSIONS REQUIRED FOR FINE-GRAINED PERSONAL ACCESS TOKEN:
# When using a custom token (CUSTOM_GITHUB_TOKEN secret), the token must have:
# - Repository access: This repository (or "All repositories" for organization-wide use)
# - Repository permissions:
#   - Pull requests: Write (to add labels to pull requests)
#   - Metadata: Read (to access repository information)
#
# SETUP INSTRUCTIONS:
# 1. Create a fine-grained personal access token at: https://github.com/settings/tokens?type=beta
# 2. Grant the permissions listed above
# 3. Add the token as a repository secret named 'CUSTOM_GITHUB_TOKEN'
# 4. This enables the workflow to run successfully for external contributors
#
# NOTE: Without a custom token, the workflow may fail for external contributors
# due to GitHub's default token permission restrictions.

name: "Keeper: feature branch auto-labeling from PR description"

'on':
  pull_request:
    types: [opened, synchronize, edited, ready_for_review]

permissions:
  pull-requests: write

jobs:
  auto-label-feature-branch:
    runs-on: ubuntu-latest

    # CHANGE THIS: set your repo name here
    # this is used to prevent the workflow from running on other repos/forks
    if: github.repository == 'thenets/repo-automations' && !github.event.pull_request.draft

    steps:
      - name: Parse YAML from PR description and add feature-branch label
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CUSTOM_GITHUB_TOKEN || github.token }}
          script: |
            console.log(`Processing PR #${context.issue.number}`);

            // Get existing labels on the PR
            const { data: existingLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const existingLabelNames = existingLabels.map(label => label.name);
            console.log(`Existing labels: ${existingLabelNames.join(', ')}`);

            // Check if feature-branch label already exists
            const hasFeatureBranchLabel = existingLabelNames.includes('feature-branch');
            console.log(`Has existing feature-branch label: ${hasFeatureBranchLabel}`);

            // Skip if feature-branch label already exists to preserve manual labeling
            if (hasFeatureBranchLabel) {
              console.log('ℹ️ Feature-branch label already exists, skipping automatic assignment');
              return;
            }

            // Get PR description
            const prBody = context.payload.pull_request.body || '';
            console.log(`PR description:\n${prBody}`);

            let yamlFound = false;
            let shouldAddFeatureBranchLabel = false;

            // Look for YAML code blocks in the PR description
            const yamlBlockRegex = /```yaml\s*\n([\s\S]*?)\n\s*```/g;
            let match;

            while ((match = yamlBlockRegex.exec(prBody)) !== null) {
              const yamlContent = match[1];
              console.log(`Found YAML block:\n${yamlContent}`);

              // Parse needs_feature_branch value
              const featureBranchMatch = yamlContent.match(/^needs_feature_branch:\s*(.+)$/m);

              if (featureBranchMatch) {
                const featureBranchValue = featureBranchMatch[1].trim().replace(/#.*$/, '').trim()
                  .replace(/^["']|["']$/g, '') // Remove surrounding single or double quotes
                  .toLowerCase(); // Convert to lowercase for case-insensitive comparison
                console.log(`Found needs_feature_branch value: "${featureBranchValue}"`);

                if (featureBranchValue === '') {
                  // Empty value - skip gracefully
                  console.log('Empty needs_feature_branch value found, skipping');
                } else if (featureBranchValue === 'true') {
                  // Valid true value - add feature-branch label
                  shouldAddFeatureBranchLabel = true;
                  console.log('needs_feature_branch is true, will add feature-branch label');
                  yamlFound = true;
                } else if (featureBranchValue === 'false') {
                  // Valid false value - no action needed
                  console.log('needs_feature_branch is false, no label will be added');
                  yamlFound = true;
                } else {
                  // Invalid value - fail the workflow
                  const errorMsg = `❌ Invalid needs_feature_branch value: "${featureBranchValue}". Accepted values: true, false (case-insensitive, with optional quotes)`;
                  console.error(errorMsg);
                  throw new Error(errorMsg);
                }

                // Stop after finding the first YAML block with needs_feature_branch
                break;
              }
            }

            if (!yamlFound) {
              console.log('No needs_feature_branch field found in YAML code blocks');
              return;
            }

            // Add feature-branch label if needed
            if (shouldAddFeatureBranchLabel) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: ['feature-branch']
                });
                console.log('✅ Successfully added feature-branch label');
              } catch (error) {
                if (error.status === 403) {
                  const errorMsg = `❌ Permission denied: Unable to add 'feature-branch' label to PR #${context.issue.number}. This typically happens when the workflow is triggered by an external contributor and the repository doesn't have a CUSTOM_GITHUB_TOKEN secret configured with appropriate permissions. Repository administrators should add a CUSTOM_GITHUB_TOKEN secret with 'Pull requests: Write' permission.`;
                  console.error(errorMsg);
                  console.error('Error details:', error);
                  throw new Error(errorMsg);
                } else if (error.status === 422) {
                  // 422 could mean label already exists or label doesn't exist in repo
                  // We need to check which case it is
                  try {
                    const { data: existingLabels } = await github.rest.issues.listLabelsOnIssue({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: context.issue.number
                    });

                    const hasFeatureBranchLabel = existingLabels.some(label => label.name === 'feature-branch');
                    if (hasFeatureBranchLabel) {
                      console.log('ℹ️ Feature-branch label already exists on PR #' + context.issue.number + ' - this is expected behavior');
                    } else {
                      // Label doesn't exist on PR, so 422 means label doesn't exist in repo
                      const errorMsg = `❌ Failed to add 'feature-branch' label to PR #${context.issue.number}: Label 'feature-branch' does not exist in the repository. Please create the 'feature-branch' label in the repository settings.`;
                      console.error(errorMsg);
                      console.error('Error details:', error);
                      throw new Error(errorMsg);
                    }
                  } catch (listError) {
                    const errorMsg = `❌ Error checking existing labels on PR #${context.issue.number}: ${listError.message}`;
                    console.error(errorMsg);
                    console.error('Error details:', listError);
                    throw new Error(errorMsg);
                  }
                } else {
                  const errorMsg = `❌ Unexpected error adding feature-branch label to PR #${context.issue.number}: ${error.message}`;
                  console.error(errorMsg);
                  console.error('Error details:', error);
                  throw new Error(errorMsg);
                }
              }
            }
